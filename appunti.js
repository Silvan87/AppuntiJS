var categorie, appunti;
function caricaDaAppuntiJS() {
categorie = {"*":"*","html":"HTML","css":"CSS","js":"JavaScript","javascript":"JavaScript","ng":"Angular","angular":"Angular","php":"PHP","sql":"SQL","oop":"OOP","java":"Java","cs":"C#","c#":"C#","git":"Git"}
appunti = {"JavaScript":[[["console","messaggio","debug"],"console.log(stringa1, stringa2, stringaN);"],[["alert","avviso","messaggio"],"window.alert(stringa);"]],"PHP":[[["echo","stampa","stringa"],"Stampa una stringa nella pagina in uscita:<br><br>echo('stringa');"],[["autoload","class","spl","register"],"# spl_autoload_register() permette di caricare automaticamente tutte le classi che vengono usate con la sintassi \"new Class()\". Così, non serve specificare ogni volta \"require a; require b; ...\", basta specificare una sola volta \"require '__autoload.php';\" (questo file speciale solitamente viene scritto con due underscore __ all'inizio).<br><br># N.B. Convenzione da rispettare: ciascuna classe deve stare in un singolo file ed il file deve avere lo stesso nome della classe.<br><br>## File: __autoload.php ##<br>&lt;?php<br>spl_autoload_register(function($nome_classe) {<br>&nbsp;&nbsp;&nbsp; // Convenzione: un file per ogni classe, e file con stesso nome della classe<br>&nbsp;&nbsp;&nbsp; $path = $_SERVER['DOCUMENT_ROOT'] . '/class/' . $nome_classe . '.php';<br>&nbsp;&nbsp;&nbsp; require $path;<br>});<br><br>## File: esempio.php ##<br>&lt;?php<br>require '__autoload.php';<br><br>$esempio = new Esempio();<br>$istanza = new ClasseAutomaticamenteInclusa();<br>$unAltro = new NonServeIncludermi();"]],"Git":[[["utilizzo","uso","scopo"],"Git è un CVS (Sistema di Controllo di Versione) che è utile localmente ed in remoto:<br><br>- In locale: permette di avere copie di backup, mentre il lavoro avanza con nuove funzionalità. Quindi offre possibilità di recuperare versioni precedenti ed avere uno storico con tutte le modifiche commentate.<br><br>- In remoto: più sviluppatori possono collaborare e sincronizzare i loro lavori con il deposito in remoto, fondamentalmente ciò avviene tramite una logica a rami, ogni serie di modifiche viene realizzata su un ramo e questo può essere innestato sul progetto principale insieme ad altri rami. Possono coesistere anche dei rami principali dedicati alla versione stabile, di testing e di sviluppo.<br>"],[["installazione","download"],"Git è multipiattaforma e può essere scaricato dal sito ufficiale:<br>https://git-scm.com/download<br><br>In linux è disponibile nel software center.<br>"],[["configurazione"],"Ci sono 3 livelli di configurazione: tutti gli utenti (--system), singolo utente (--global), singolo progetto (cartella .git del progetto). Il livello più specifico sovrascrive quello più generale.<br><br>L'identità definita da nome ed email va inserita come prima cosa a livello utente:<br><br>git config --global user.name \"Mio nome\"<br>git config --global user.email \"mia@email.it\"<br><br>Per controllare le configurazioni:<br><br>git config --list<br><br>È possibile attivare una cache di breve durata (pochi minuti) per le credenziali, così che in una serie di invii successivi non devono essere specificate ogni volta:<br><br>git config --global credential.helper cache<br><br>Di default Git usa l'editor Vim, probabilmente è preferibile usare nano:<br><br>git config --global core.editor \"nano\"<br><br>È comodo usare delle abbreviazioni per alcuni comandi molto usati, al posto di 'commit', potremo scrivere 'cm'; al posto di 'branch', 'br'; 'checkout', 'co' e 'status', 'st':<br><br>git config --global alias.co checkout<br>git config --global alias.br branch<br>git config --global alias.cm commit<br>git config --global alias.st status"],[["avviare","progetto","nuovo","init"],"Creare una cartella con il nome del progetto, collocarsi al suo interno e partire con:<br><br>git init<br><br>Se la cartella contiene già dei file sarà possibile inserirli come prima modifica. Per inviare il progetto e le successive modifiche ad un deposito remoto, occorre specificare l'URL del deposito:<br><br>git remote add origin https://github.com/Autore/NomeDeposito<br><br>- origin è il nome del deposito, può essere modificato, così da averne più di uno."],[["clonare","progetto"],"Recuperare l'URL del progetto da clonare (copiare in locale) e usare:<br><br>git clone https://github.com/Autore/Progetto<br><br>Verrà creata una cartella con il nome del progetto, per personalizzare il nome della cartella:<br><br>git clone https://github.com/Autore/Progetto NomeCartella<br>"],[["rimuovere","file","modifica","staging"],"= Escludere un file dalla fase di modifica =<br><br>Se il file è segnato come modificato dobbiamo escluderlo dall'albero inserendo il suo nome in \".git/info/exclude\", ma questo avrà effetto solo per le prossime volte. Per la situazione corrente usare:<br><br>git rm --cached nome_file<br><br>= Escludere un file dalla fase di staging =<br><br>Se il file è già stato allestito per un commit e vogliamo continuare a monitorarlo, ma escluderlo dal commit preparato (e non ancora eseguito), usare:<br><br>git reset HEAD nome_file"]],"*":[[["preparare","angularjs"],"AngularJS dipende da NodeJS<br><br>- Installare NodeJS, si tratta di un'applicazione che esegue JS (arricchito con qualche potenzialità) fuori dal browser e quindi anche lato server. NodeJS è una dipendenza di Chrome.<br>- Installare Git perché è usato per recuperare le dipendenze di volta in volta necessarie.<br>- La presenza di NodeJS mette a disposizione il comando 'npm' che è un gestore di pacchetti.<br>- angular-cli, installarlo con: npm install -g @angular/cli (permessi amministratore)<br>- Ora è disponibile il comando 'ng' che sarebbe l'abbreviazione di angular.<br>- Per installare una nuova applicazione: ng new nome_progetto<br>- Si lavora principalmente in: nome_progetto/src<br>- Collocarsi su: cd nome_progetto ed eseguire: ng serve (così avremo un server in locale)<br>"]],"Java":[[["web","enterprise","edition","ee","introduzione"],"== Java e Web ==<br><br>JavaEE (Enterprise Edition) è un contenitore di librerie Java:<br><br>- JDBC (Java DataBase Connectivity)<br>- Servlet-JSP (Java Server Pages)<br>- EJB<br>- JSF (Java Server Faces)<br><br>= Servlet =<br>Classe java che gestisce un sistema client-server di richieste e risposte.<br>Funziona all'interno di un contenitore java che fa da Server Application / Web Server (alcuni esempi: Tomcat, JBoss, Glassfish, ecc.). Questi fanno funzionare le servlet.<br><br>I Server Java si dividono in due gruppi:<br><br>-- Application Server<br>container java per tutto il container EE compresi gli EJB (EE Java Beans)<br>(es. JBoss)<br><br>-- Web Server<br>container java per servlet e JSP e JSF<br>(es. Tomcat)<br>"],[["preparare","apache","tomcat"],"In Eclipse occorre dedicare un Workspace per EE ed avere la giusta perspective. Serve aver scaricato il file zip Apache Tomcat che contiene il server.<br><br>- C'è una scheda dei server (in basso)<br>- Tasto destro &gt; Proprietà - Scegliere \"Switch Location\" per non legare il server ad Eclipse<br>- Sul server con doppio click si apre la finestra Overview, qui impostiamo la porta 8081 (per evitare eventuali conflitti col database Oracle o altro) e la deploy path dovrebbe essere: /opt/apache-tomcat/webapps<br>- Definire gli utenti, la configurazione essenziale in tomcatusers.xml è:<br><br>&lt;role rolename=\"tomcat\"/&gt;<br>&lt;role rolename=\"admin\"/&gt;<br>&lt;role rolename=\"admin-gui\"/&gt;<br>&lt;role rolename=\"manager-gui\"/&gt;<br>&lt;user username=\"tomcat\" password=\"password\" roles=\"tomcat,admin,admin-gui,manager-gui\"/&gt;<br><br>ovvero 4 ruoli essenziali tutti attribuiti ad un super utente tomcat.<br><br>- Avviando il server si potrà visitare: http://localhost:8081<br>- Il passo successivo è solitamente creare un nuovo Dynamic Web Project<br>"]],"SQL":[[["creare","eliminare","database","namespace"],"CREATE DATABASE nome_database;<br><br>Se in seguito si devono fare varie operazioni sul database si può usare un namespace:<br><br>USE nome_database;<br><br>Per eliminare:<br><br>DROP DATABASE nome_database;"]]}
}
